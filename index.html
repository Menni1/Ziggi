<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>Instant P2P Chat — OneFile</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="P2P Chat">
<style>
  :root{
    --bg: #0b0c0f;
    --bg-elev: #14161a;
    --bg-input: #1a1c22;
    --t-primary: #ffffff;
    --t-secondary: #aeb3bd;
    --t-muted:#7b818b;
    --accent: #0a84ff; /* iOS blue */
    --sent: #0a84ff;
    --recv: #262b33;
    --border: #23262c;
    --ok: #30d158;
    --warn: #ff9f0a;
    --err: #ff453a;
    --shadow: 0 10px 30px rgba(0,0,0,.35);
    --radius: 18px;
  }
  @media (prefers-color-scheme: light){
    :root{
      --bg: #f5f6f8;
      --bg-elev:#ffffff;
      --bg-input:#f2f3f6;
      --t-primary:#0b0c0f;
      --t-secondary:#3b3f45;
      --t-muted:#6b7280;
      --recv:#e9edf3;
      --border:#e6e9ef;
      --shadow: 0 10px 30px rgba(0,0,0,.08);
    }
  }
  *{box-sizing: border-box; -webkit-tap-highlight-color: transparent;}
  html,body{height:100%; background:var(--bg); color:var(--t-primary); font: 16px/1.2 -apple-system, BlinkMacSystemFont, "SF Pro Text", "SF Pro Display", system-ui, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, sans-serif; margin:0;}
  .app{
    min-height: 100dvh;
    display:flex; flex-direction:column;
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
  }
  header{
    position:sticky; top:0; z-index: 10;
    background: var(--bg-elev);
    box-shadow: 0 1px 0 var(--border);
  }
  .bar{
    display:flex; align-items:center; gap:10px;
    padding: 14px 16px calc(14px + env(safe-area-inset-top)) 16px;
    padding-top: 14px;
  }
  .title{
    display:flex; flex-direction:column; gap:4px;
  }
  .title h1{
    font-size: 17px; margin:0; font-weight: 700;
    letter-spacing:.2px;
  }
  .subtitle{font-size:12px; color: var(--t-muted); display:flex; align-items:center; gap:6px;}
  .status-dot{
    width:8px; height:8px; border-radius:50%;
    background: var(--warn); box-shadow: 0 0 0 3px color-mix(in oklab, var(--warn) 20%, transparent);
  }
  .status-disconnected{ background: var(--err); }
  .status-connecting{ background: var(--warn); }
  .status-connected{ background: var(--ok); }
  .spacer{ flex:1; }
  .icon-btn{
    width:34px; height:34px; border-radius:10px; background:var(--bg);
    border:1px solid var(--border); display:grid; place-items:center;
    box-shadow: var(--shadow);
    cursor:pointer;
  }
  .icon-btn:active{ transform: scale(.98); }
  .icon{ width:20px; height:20px; display:block; }
  main{
    flex:1; overflow:auto; -webkit-overflow-scrolling: touch;
    padding: 14px 12px;
    background: linear-gradient(180deg, color-mix(in oklab, var(--bg) 96%, black) 0%, var(--bg) 30%);
  }
  .hint{
    text-align:center; color: var(--t-muted);
    font-size: 13px; margin: 12px 0;
  }
  .bubble{
    max-width: 76%;
    padding: 10px 12px; border-radius: 16px;
    margin: 6px 0; word-wrap: break-word; word-break: break-word;
    position: relative;
  }
  .msg-row{ display:flex; }
  .me{ justify-content: flex-end; }
  .me .bubble{
    background: var(--sent); color: white; border-bottom-right-radius: 6px;
  }
  .them .bubble{
    background: var(--recv); color: var(--t-primary); border-bottom-left-radius: 6px;
  }
  .time{
    display:block; font-size: 11px; opacity: .7; margin-top: 6px;
  }
  footer{
    position: sticky; bottom: 0; background: var(--bg-elev);
    box-shadow: 0 -1px 0 var(--border);
  }
  .composer{
    display:flex; align-items:flex-end; gap:8px; padding:10px 12px calc(10px + env(safe-area-inset-bottom)) 12px;
  }
  .field{
    flex:1; display:flex; align-items:center; gap:8px;
    background: var(--bg-input); border:1px solid var(--border);
    border-radius: 18px; padding: 10px 12px;
  }
  textarea{
    flex:1; border:0; outline:0; background:transparent; color:var(--t-primary);
    resize:none; max-height: 110px; height: 22px; line-height: 22px;
    font: inherit;
  }
  .send{
    border:0; outline:0;
    background: var(--accent);
    color:white; padding: 10px 14px; border-radius: 14px; font-weight: 700;
    opacity:.5;
  }
  .send.ready{ opacity:1; }
  .pill{
    display:inline-flex; align-items:center; gap:8px;
    background: var(--bg-input); border:1px dashed var(--border);
    color: var(--t-secondary);
    padding:10px 12px; border-radius: 12px; font-size: 13px;
  }
  /* Sheet */
  .sheet-backdrop{
    position: fixed; inset:0; background: rgba(0,0,0,.35);
    backdrop-filter: blur(3px);
    opacity:0; pointer-events:none; transition: .25s ease;
  }
  .sheet{ position: fixed; left:0; right:0; bottom: -70%;
    background: var(--bg-elev); border-top-left-radius: 20px; border-top-right-radius: 20px;
    box-shadow: 0 -10px 40px rgba(0,0,0,.35); padding-bottom: env(safe-area-inset-bottom);
    transition: .3s ease;
  }
  .sheet.open + .sheet-backdrop{ opacity:1; pointer-events: all; }
  .sheet.open{ bottom: 0; }
  .sheet .grip{
    width:48px; height:5px; border-radius:3px; background: var(--border);
    margin: 10px auto;
  }
  .sheet .content{ padding: 8px 16px 18px; }
  .tabs{ display:flex; gap:8px; background: var(--bg); padding:6px; border-radius: 14px; border:1px solid var(--border); }
  .tabs button{ flex:1; border:0; background:transparent; color: var(--t-secondary); padding:8px 12px; border-radius: 10px; font-weight:600; }
  .tabs button.active{ background: var(--bg-elev); color: var(--t-primary); border:1px solid var(--border); }
  .section{ margin-top: 14px; }
  .section h3{ font-size: 14px; color: var(--t-secondary); margin: 0 0 8px 0; }
  .row{ display:flex; gap:8px; }
  .row > * { flex:1; }
  textarea.offer, textarea.answer{
    width:100%; min-height: 120px; background: var(--bg-input); border:1px solid var(--border); border-radius: 12px; color: var(--t-primary);
    padding: 10px; font: 13px/1.25 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  }
  .small{ font-size: 12px; color: var(--t-muted); }
  .btn{ border:1px solid var(--border); background:var(--bg-input); color:var(--t-primary); padding: 10px 12px; border-radius: 12px; font-weight:600; }
  .btn.primary{ background: var(--accent); border-color: var(--accent); color:white; }
  .btn.danger{ background: var(--err); border-color: var(--err); color:white; }
  .btn-row{ display:flex; gap:10px; }
  .kudo { text-align:center; font-size:12px; color: var(--t-muted); margin-top: 12px;}
  .hidden{ display:none !important; }
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="bar">
      <div class="title">
        <h1 id="chatTitle">Neuer Chat</h1>
        <div class="subtitle">
          <div id="statusDot" class="status-dot status-disconnected"></div>
          <span id="statusText">Offline • kein Peer verbunden</span>
        </div>
      </div>
      <div class="spacer"></div>
      <button class="icon-btn" id="btnConnect" aria-label="Verbinden" title="Verbinden">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4"/>
          <path d="M21 9a4 4 0 0 0-4-4H7a4 4 0 0 0-4 4"/>
          <path d="M7 12h10"/>
        </svg>
      </button>
      <button class="icon-btn" id="btnMore" aria-label="Mehr" title="Mehr">
        <svg class="icon" viewBox="0 0 24 24" fill="currentColor">
          <circle cx="5" cy="12" r="2"/><circle cx="12" cy="12" r="2"/><circle cx="19" cy="12" r="2"/>
        </svg>
      </button>
    </div>
  </header>

  <main id="timeline" aria-live="polite">
    <div class="hint">Tippe oben auf „Verbinden“, um einen Peer‑to‑Peer‑Chat ohne Server zu starten. Alles bleibt lokal &amp; Ende‑zu‑Ende verschlüsselt (WebRTC).</div>
  </main>

  <footer>
    <div class="composer">
      <div class="field">
        <button class="icon-btn" id="btnClearInput" title="Leeren">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M3 6h18"/>
            <path d="M19 6l-2 14a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2L5 6"/>
            <path d="M10 11v6M14 11v6"/>
            <path d="M9 6l1-3h4l1 3"/>
          </svg>
        </button>
        <textarea id="input" placeholder="Nachricht" rows="1"></textarea>
      </div>
      <button class="send" id="sendBtn" disabled>Senden</button>
    </div>
  </footer>
</div>

<!-- Bottom Sheet: Connect & Settings -->
<div id="sheet" class="sheet" role="dialog" aria-modal="true" aria-labelledby="sheetTitle">
  <div class="grip"></div>
  <div class="content">
    <div class="tabs" role="tablist">
      <button id="tabConnect" role="tab" aria-selected="true" class="active">Verbinden</button>
      <button id="tabSettings" role="tab" aria-selected="false">Einstellungen</button>
    </div>
    <div id="connectPane" class="pane">
      <div class="section">
        <h3>Wie funktioniert’s?</h3>
        <p class="small">Kein Backend. Verbindung läuft direkt Gerät‑zu‑Gerät via WebRTC DataChannel. Für die Kopplung wird einmalig ein Text („Angebot/Antwort“) manuell ausgetauscht (z. B. per AirDrop, iMessage).</p>
      </div>

      <div class="section">
        <div class="tabs" id="roleTabs">
          <button id="roleStarter" class="active">Ich starte</button>
          <button id="roleJoiner">Ich trete bei</button>
        </div>
      </div>

      <div id="starterFlow" class="section">
        <h3>1) Angebot erstellen &amp; teilen</h3>
        <div class="btn-row" style="margin-bottom:8px;">
          <button class="btn primary" id="btnCreateOffer">Angebot erzeugen</button>
          <button class="btn" id="btnCopyOffer" disabled>Kopieren</button>
        </div>
        <textarea class="offer" id="offerOut" placeholder="Hier erscheint dein Angebot (SDP)…" readonly></textarea>
        <p class="small">Sende diesen Text an dein Gegenüber. Dann fügt er ihn bei sich ein und schickt dir die „Antwort“ zurück.</p>

        <h3>2) Antwort einfügen</h3>
        <textarea class="answer" id="answerIn" placeholder="Antwort des Gegenübers hier einfügen…"></textarea>
        <div class="btn-row" style="margin-top:8px;">
          <button class="btn primary" id="btnAcceptAnswer" disabled>Antwort akzeptieren</button>
          <button class="btn" id="btnResetStarter">Zurücksetzen</button>
        </div>
      </div>

      <div id="joinerFlow" class="section hidden">
        <h3>1) Angebot einfügen</h3>
        <textarea class="offer" id="offerIn" placeholder="Angebot des Gegenübers hier einfügen…"></textarea>
        <div class="btn-row" style="margin-top:8px;">
          <button class="btn primary" id="btnAcceptOffer" disabled>Angebot akzeptieren</button>
          <button class="btn" id="btnResetJoiner">Zurücksetzen</button>
        </div>

        <h3>2) Antwort erzeugen &amp; zurücksenden</h3>
        <div class="btn-row" style="margin-bottom:8px;">
          <button class="btn" id="btnCopyAnswer" disabled>Kopieren</button>
        </div>
        <textarea class="answer" id="answerOut" placeholder="Hier erscheint deine Antwort (SDP)…" readonly></textarea>
        <p class="small">Schicke diese Antwort zurück. Sobald der andere sie eingefügt hat, seid ihr verbunden.</p>
      </div>
      <div class="kudo">Tipp: „Zum Home‑Bildschirm“ hinzufügen für echte App‑Optik.</div>
    </div>

    <div id="settingsPane" class="pane hidden">
      <div class="section">
        <h3>Profil</h3>
        <div class="row">
          <input id="displayName" class="btn" placeholder="Dein Anzeigename" />
          <button id="btnSaveProfile" class="btn primary">Speichern</button>
        </div>
      </div>
      <div class="section">
        <h3>Chat</h3>
        <div class="btn-row">
          <button id="btnExport" class="btn">Chat exportieren</button>
          <button id="btnImport" class="btn">Chat importieren</button>
          <button id="btnClearChat" class="btn danger">Alles löschen</button>
        </div>
        <input id="importFile" type="file" accept="application/json" class="hidden" />
      </div>
      <div class="section">
        <h3>Info &amp; Datenschutz</h3>
        <p class="small">
          Nachrichten werden lokal auf deinem Gerät gespeichert (localStorage). Es gibt keine Server. WebRTC verschlüsselt die Verbindung (DTLS). Größere Dateien werden nicht unterstützt, Fokus auf Text‑Chat.
        </p>
      </div>
    </div>
  </div>
</div>
<div id="sheetBackdrop" class="sheet-backdrop" aria-hidden="true"></div>

<script>
(() => {
  "use strict";

  // ---------- DOM helpers
  const $ = sel => document.querySelector(sel);
  const on = (el, ev, fn, opts) => el.addEventListener(ev, fn, opts);
  const sleep = ms => new Promise(r => setTimeout(r, ms));

  // ---------- State
  const state = {
    pc: null,
    dc: null,
    role: "starter", // or "joiner"
    connected: false,
    history: [], // {who:'me'|'them', text, ts}
    peerLabel: "Peer",
    selfName: localStorage.getItem("p2p_name") || "Ich",
    chatKey: "p2p_history_v1",
  };

  // ---------- UI Elements
  const timeline = $("#timeline");
  const input = $("#input");
  const sendBtn = $("#sendBtn");
  const statusDot = $("#statusDot");
  const statusText = $("#statusText");
  const chatTitle = $("#chatTitle");
  const sheet = $("#sheet");
  const sheetBackdrop = $("#sheetBackdrop");

  const tabConnect = $("#tabConnect");
  const tabSettings = $("#tabSettings");
  const connectPane = $("#connectPane");
  const settingsPane = $("#settingsPane");
  const roleStarter = $("#roleStarter");
  const roleJoiner = $("#roleJoiner");
  const starterFlow = $("#starterFlow");
  const joinerFlow = $("#joinerFlow");

  const offerOut = $("#offerOut");
  const answerIn = $("#answerIn");
  const btnCreateOffer = $("#btnCreateOffer");
  const btnCopyOffer = $("#btnCopyOffer");
  const btnAcceptAnswer = $("#btnAcceptAnswer");
  const btnResetStarter = $("#btnResetStarter");

  const offerIn = $("#offerIn");
  const answerOut = $("#answerOut");
  const btnAcceptOffer = $("#btnAcceptOffer");
  const btnCopyAnswer = $("#btnCopyAnswer");
  const btnResetJoiner = $("#btnResetJoiner");

  const displayName = $("#displayName");
  const btnSaveProfile = $("#btnSaveProfile");
  const btnExport = $("#btnExport");
  const btnImport = $("#btnImport");
  const importFile = $("#importFile");
  const btnClearChat = $("#btnClearChat");
  const btnConnect = $("#btnConnect");
  const btnMore = $("#btnMore");
  const btnClearInput = $("#btnClearInput");

  // ---------- Init
  function init(){
    displayName.value = state.selfName;
    loadHistory();
    renderHistory();
    updateStatus("disconnected", "Offline • kein Peer verbunden");
    autoResizeTextarea();
  }

  // ---------- History
  function loadHistory(){
    try{
      const raw = localStorage.getItem(state.chatKey);
      if(raw){ state.history = JSON.parse(raw); }
    }catch(e){ console.warn(e); }
  }
  function saveHistory(){
    try{
      localStorage.setItem(state.chatKey, JSON.stringify(state.history));
    }catch(e){ console.warn(e); }
  }
  function addMessage(who, text, ts = Date.now()){
    state.history.push({who, text, ts});
    saveHistory();
    renderMessage({who, text, ts});
  }

  function renderHistory(){
    timeline.innerHTML = '<div class="hint">Lokaler Verlauf • nur auf diesem Gerät gespeichert</div>';
    for(const msg of state.history){
      renderMessage(msg, false);
    }
    scrollToBottom();
  }
  function renderMessage(msg, shouldScroll = true){
    const row = document.createElement("div");
    row.className = "msg-row " + (msg.who === "me" ? "me" : "them");
    const bubble = document.createElement("div");
    bubble.className = "bubble";
    bubble.textContent = msg.text;
    const time = document.createElement("span");
    time.className = "time";
    const dt = new Date(msg.ts);
    time.textContent = dt.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
    bubble.appendChild(time);
    row.appendChild(bubble);
    timeline.appendChild(row);
    if(shouldScroll) scrollToBottom();
  }
  function scrollToBottom(){
    requestAnimationFrame(() => { timeline.scrollTop = timeline.scrollHeight; });
  }

  // ---------- Status UI
  function updateStatus(kind, text){
    statusText.textContent = text;
    statusDot.classList.remove("status-disconnected","status-connecting","status-connected");
    if(kind === "disconnected") statusDot.classList.add("status-disconnected");
    if(kind === "connecting") statusDot.classList.add("status-connecting");
    if(kind === "connected") statusDot.classList.add("status-connected");
  }

  // ---------- Sheet controls
  function openSheet(){
    sheet.classList.add("open");
    sheetBackdrop.classList.add("open");
    sheet.setAttribute("aria-hidden", "false");
  }
  function closeSheet(){
    sheet.classList.remove("open");
    sheetBackdrop.classList.remove("open");
    sheet.setAttribute("aria-hidden", "true");
  }
  on(sheetBackdrop, "click", closeSheet);
  on(btnConnect, "click", openSheet);
  on(btnMore, "click", () => {
    openSheet();
    selectTab("settings");
  });

  // Tabs
  function selectTab(which){
    if(which === "connect"){
      tabConnect.classList.add("active"); tabConnect.setAttribute("aria-selected","true");
      tabSettings.classList.remove("active"); tabSettings.setAttribute("aria-selected","false");
      connectPane.classList.remove("hidden"); settingsPane.classList.add("hidden");
    }else{
      tabSettings.classList.add("active"); tabSettings.setAttribute("aria-selected","true");
      tabConnect.classList.remove("active"); tabConnect.setAttribute("aria-selected","false");
      settingsPane.classList.remove("hidden"); connectPane.classList.add("hidden");
    }
  }
  on(tabConnect, "click", () => selectTab("connect"));
  on(tabSettings, "click", () => selectTab("settings"));

  // Role switch
  function selectRole(role){
    state.role = role;
    if(role === "starter"){
      roleStarter.classList.add("active");
      roleJoiner.classList.remove("active");
      starterFlow.classList.remove("hidden");
      joinerFlow.classList.add("hidden");
    }else{
      roleJoiner.classList.add("active");
      roleStarter.classList.remove("active");
      joinerFlow.classList.remove("hidden");
      starterFlow.classList.add("hidden");
    }
  }
  on(roleStarter, "click", () => selectRole("starter"));
  on(roleJoiner, "click", () => selectRole("joiner"));

  // ---------- Composer
  function autoResizeTextarea(){
    input.style.height = "22px";
    input.style.height = Math.min(input.scrollHeight, 110) + "px";
  }
  on(input, "input", () => {
    autoResizeTextarea();
    const hasText = input.value.trim().length > 0;
    sendBtn.disabled = !hasText;
    sendBtn.classList.toggle("ready", hasText);
  });
  on(btnClearInput, "click", () => { input.value = ""; input.dispatchEvent(new Event("input")); input.focus(); });

  async function sendMessage(){
    const text = input.value.trim();
    if(!text) return;
    addMessage("me", text);
    input.value = "";
    input.dispatchEvent(new Event("input"));

    // Try to send via datachannel if connected
    try{
      if(state.connected && state.dc && state.dc.readyState === "open"){
        state.dc.send(JSON.stringify({type:"msg", text, ts: Date.now(), name: state.selfName}));
      }
    }catch(e){ console.warn("Send failed", e); }
  }
  on(sendBtn, "click", sendMessage);
  on(input, "keydown", (e) => {
    if(e.key === "Enter" && !e.shiftKey){
      e.preventDefault();
      sendMessage();
    }
  });

  // ---------- WebRTC (no backend; manual SDP exchange)
  const rtcConfig = {
    iceServers: [
      {urls: ["stun:stun.l.google.com:19302","stun:stun1.l.google.com:19302"]}
    ]
  };

  function makePeer(){
    cleanupPeer();
    state.pc = new RTCPeerConnection(rtcConfig);
    state.pc.onconnectionstatechange = () => {
      const s = state.pc.connectionState;
      if(s === "connected"){
        state.connected = true;
        updateStatus("connected", `Verbunden mit ${state.peerLabel}`);
        chatTitle.textContent = state.peerLabel;
        closeSheet();
      } else if(s === "connecting"){
        updateStatus("connecting", "Verbinde…");
      } else if(s === "failed" || s === "disconnected"){
        state.connected = false;
        updateStatus("disconnected", "Verbindung getrennt");
      }
    };
    state.pc.onicegatheringstatechange = () => {
      // could update UI if needed
    };
    state.pc.ondatachannel = (ev) => {
      state.dc = ev.channel;
      attachDC();
    };
  }

  function attachDC(){
    const dc = state.dc;
    if(!dc) return;
    dc.onopen = () => {
      state.connected = true;
      updateStatus("connected", `Verbunden mit ${state.peerLabel}`);
      chatTitle.textContent = state.peerLabel;
      closeSheet();
    };
    dc.onclose = () => {
      state.connected = false;
      updateStatus("disconnected", "Verbindung geschlossen");
    };
    dc.onmessage = (ev) => {
      try{
        const data = JSON.parse(ev.data);
        if(data.type === "msg"){
          if(data.name && data.name !== "Ich"){ state.peerLabel = data.name; chatTitle.textContent = state.peerLabel; }
          addMessage("them", data.text, data.ts || Date.now());
        } else if(data.type === "hello"){
          state.peerLabel = data.name || "Peer";
          chatTitle.textContent = state.peerLabel;
        }
      }catch(_){
        // Fallback plain text
        addMessage("them", String(ev.data));
      }
    };
    // Identify ourselves
    dc.onopen && dc.onopen();
    try{
      dc.send(JSON.stringify({type:"hello", name: state.selfName}));
    }catch(_){}
  }

  async function createOffer(){
    selectRole("starter");
    makePeer();
    state.dc = state.pc.createDataChannel("chat");
    attachDC();

    updateStatus("connecting", "Angebot wird erstellt…");
    const offer = await state.pc.createOffer();
    await state.pc.setLocalDescription(offer);

    // Wait for ICE gathering to complete for a single-copy SDP
    await waitForIceComplete(state.pc);
    const sdp = btoa(JSON.stringify(state.pc.localDescription));
    offerOut.value = sdp;
    btnCopyOffer.disabled = !sdp;
    updateStatus("connecting", "Angebot bereit — teile es mit dem Gegenüber");
  }

  async function acceptAnswer(){
    const s = answerIn.value.trim();
    if(!s) return;
    try{
      const desc = JSON.parse(atob(s));
      await state.pc.setRemoteDescription(desc);
      updateStatus("connecting", "Antwort akzeptiert — stelle Verbindung her…");
    }catch(e){
      alert("Konnte die Antwort nicht lesen. Stelle sicher, dass der komplette Text eingefügt wurde.");
      console.error(e);
    }
  }

  async function acceptOffer(){
    selectRole("joiner");
    makePeer();
    const s = offerIn.value.trim();
    if(!s){ return; }
    try{
      const desc = JSON.parse(atob(s));
      await state.pc.setRemoteDescription(desc);

      state.dc = state.pc.createDataChannel("chat"); // ensure we can receive if other doesn't create
      attachDC();

      const answer = await state.pc.createAnswer();
      await state.pc.setLocalDescription(answer);
      await waitForIceComplete(state.pc);
      const sdp = btoa(JSON.stringify(state.pc.localDescription));
      answerOut.value = sdp;
      btnCopyAnswer.disabled = !sdp;
      updateStatus("connecting", "Antwort erzeugt — gib sie zurück an den Starter");
    }catch(e){
      alert("Konnte das Angebot nicht lesen. Bitte prüfe den Text.");
      console.error(e);
    }
  }

  function cleanupPeer(){
    try{ if(state.dc){ state.dc.close(); } }catch(_){}
    try{ if(state.pc){ state.pc.close(); } }catch(_){}
    state.dc = null; state.pc = null; state.connected = false;
  }

  function waitForIceComplete(pc){
    return new Promise(resolve => {
      if(pc.iceGatheringState === "complete"){ resolve(); return; }
      const check = () => {
        if(pc.iceGatheringState === "complete"){
          pc.removeEventListener("icegatheringstatechange", check);
          resolve();
        }
      };
      pc.addEventListener("icegatheringstatechange", check);
      // safety timeout
      setTimeout(() => { resolve(); }, 3000);
    });
  }

  // ---------- Settings / Profile
  on(btnSaveProfile, "click", () => {
    const name = displayName.value.trim() || "Ich";
    state.selfName = name;
    localStorage.setItem("p2p_name", name);
    chatTitle.textContent = state.connected ? state.peerLabel : "Neuer Chat";
    alert("Name gespeichert.");
  });

  on(btnExport, "click", () => {
    const data = JSON.stringify({name: state.selfName, history: state.history}, null, 2);
    const blob = new Blob([data], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "p2p-chat-export.json";
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(url);
    a.remove();
  });
  on(btnImport, "click", () => importFile.click());
  on(importFile, "change", async (e) => {
    const file = e.target.files[0];
    if(!file) return;
    const text = await file.text();
    try{
      const obj = JSON.parse(text);
      if(Array.isArray(obj.history)){
        state.history = obj.history;
        saveHistory();
        renderHistory();
        alert("Import erfolgreich.");
      }else{
        alert("Ungültige Datei.");
      }
    }catch(_){
      alert("Konnte Datei nicht lesen.");
    }
    importFile.value = "";
  });

  on(btnClearChat, "click", () => {
    if(confirm("Wirklich gesamten Chatverlauf löschen?")){
      state.history = [];
      saveHistory();
      renderHistory();
    }
  });

  // ---------- Connect sheet controls
  on(btnCreateOffer, "click", createOffer);
  on(btnCopyOffer, "click", async () => {
    await navigator.clipboard.writeText(offerOut.value);
    btnCopyOffer.textContent = "Kopiert";
    setTimeout(()=>btnCopyOffer.textContent="Kopieren", 1200);
  });
  on(answerIn, "input", () => {
    btnAcceptAnswer.disabled = answerIn.value.trim().length === 0;
  });
  on(btnAcceptAnswer, "click", acceptAnswer);
  on(btnResetStarter, "click", () => {
    offerOut.value = ""; answerIn.value = ""; btnCopyOffer.disabled = true; btnAcceptAnswer.disabled = true;
    cleanupPeer(); updateStatus("disconnected", "Offline • kein Peer verbunden");
  });

  on(offerIn, "input", () => {
    btnAcceptOffer.disabled = offerIn.value.trim().length === 0;
  });
  on(btnAcceptOffer, "click", acceptOffer);
  on(btnCopyAnswer, "click", async () => {
    await navigator.clipboard.writeText(answerOut.value);
    btnCopyAnswer.textContent = "Kopiert";
    setTimeout(()=>btnCopyAnswer.textContent="Kopieren", 1200);
  });
  on(btnResetJoiner, "click", () => {
    offerIn.value = ""; answerOut.value = ""; btnCopyAnswer.disabled = true;
    cleanupPeer(); updateStatus("disconnected", "Offline • kein Peer verbunden");
  });

  // Open/close the sheet with buttons
  on($("#sheetBackdrop"), "click", closeSheet);

  // ---------- Start
  init();
})();
</script>
</body>
</html>
